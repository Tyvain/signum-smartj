package bt.dapps;

import bt.*;
import bt.ui.EmulatorWindow;

/**
 * A fully  decentralized and unstoppable black jack.
 * <p>
 * Simple Crypto Black Jack
 * <p>
 * Aces always equals 11
 * Players and banks stop drawing cars at 17
 * if draw bank win
 * <p>
 * Player can play to become the bank.
 * To do so they need to send mon coins than the current bank, with a tx message 'bank'
 * If they succeed, they become the bank. The previous bank money is send back the to previous owner.
 * <p>
 * if bank win: 1/5 of bet is send back to the bank owner, 1/5 send to the jack pot, 3/5 goes in the bank money.
 * if player make bank go bankrup, he wins the jack pot
 * <p>
 * A special random generator using 10 blocks and multiple hashes is used to
 * make any miner manipulation unprofitable. All bets placed during the hash
 * seed generation are moved to the next round.
 *
 * @author Styv182
 */
public class CryptoBlackJack extends Contract {

	public static final long GAS_FEE = 2 * ONE_BURST;
	Timestamp lastRunning;
	long nextRoundBlock;
	Address holdersContract;
	Transaction nextTx;
	Timestamp lastPaid;
	Address nextPlayerToPay;

	//Helper for drawing cards
	long hash, hash1, hashBase;
	long hashCounter;
	long roundNumber;
	long drawCard;
	long playerScore = 0;
	long bankScore = 0;
	// Number of blocks used to get the draw numbers hash
	long HASH_BLOCKS = 9;

	// time difference between rounds in minutes (24h = 1440 minutes)
	public static final long DELTA_T = 5;
	long DELTA_T_BLOCKS = DELTA_T / 4;
	long DELTA_LAST = HASH_BLOCKS * 4;

	// bank bank
	long jackpotMoney;
	Address currentBankOwner;
	long currentBankMoney;
	long BANK_STR_LONG_VALUE = 1802396002; // "bank" String = 1802396002 in long

	//static numbers
	long SEVENTEEN = 17;
	long ONE = 1;
	long TWO = 2;
	static final long HASH_MASK = 0x0FFFFFFFFFFFFFFFL;

	public CryptoBlackJack() {
		holdersContract = getCreator();
		lastRunning = getBlockTimestamp().addMinutes(DELTA_T - DELTA_LAST);
		nextRoundBlock = getBlockHeight() + DELTA_T_BLOCKS - HASH_BLOCKS;
		// Infinite loop sorting at every DELTA_T blocks
		while (true) {
			// Avoid any delay if we need more than one block to run all the bets
			sleep(nextRoundBlock - getBlockHeight());
			playOneRound();
			nextRoundBlock = nextRoundBlock + DELTA_T_BLOCKS;
			lastRunning = lastRunning.addMinutes(DELTA_T);
		}
	}

	private void playOneRound() {
		// construct the winning seed based on 9 different blocks
		hash1 = getPrevBlockHash1();
		hash = hash1;
		hashCounter = ONE;
		while (hashCounter < HASH_BLOCKS) {
			sleep(ONE);
			hash *= TWO; // shift by one bit
			hash += (getPrevBlockHash1() & ONE);
			hashCounter += ONE;
		}
		hash = performSHA256_64(hash, hash1);
		roundNumber += ONE;
		hashBase = hash;

		// Play game
		while (true) {
			nextTx = getTxAfterTimestamp(lastPaid);
			if (nextTx == null || nextTx.getTimestamp().ge(lastRunning)) break;
			nextPlayerToPay = nextTx.getSenderAddress();
			if (currentBankOwner == null) {
				// current player becomes the bank, keep playing
				changingBankOwnership();
			} else if (BANK_STR_LONG_VALUE == nextTx.getMessage1()) {
				// change bank owner algorithm
				changingBankOwnership();
			} else {
				playerPlay();
			}
		}
	}

	private void changingBankOwnership() {
		if (nextTx.getAmount() > currentBankMoney) { // switch bank owner succeed
			// sendMoney back to current owner
			sendAmount(currentBankMoney, currentBankOwner);
			// switch current bank
			currentBankOwner = nextTx.getSenderAddress();
			currentBankMoney = nextTx.getAmount();
		} else {
			// switch bank owner fail: give 10% to jackpot, 90% back to owner
			jackpotMoney += nextTx.getAmount() / 10;
			sendAmount(nextTx.getAmount() / 90, nextTx.getSenderAddress());
		}
	}

	private void playerPlay() {
		playerScore = playerDrawCards();

		if (playerScore > 21) {
			bankWin();
			return;
		}

		bankScore = playerDrawCards();

		if (bankScore > 21) {
			playerWin();
			return;
		}

		if (playerScore > bankScore) {
			playerWin();
			return;
		}

		bankWin();
	}

	private long playerDrawCards() {
		long score = 0;
		while (score < SEVENTEEN && score < 21) {
			score += drawCard();
		}
		return score;
	}


	private void bankWin() {
		jackpotMoney += nextTx.getAmount() / 5;
		sendAmount(nextTx.getAmount() / 5, currentBankOwner);
		currentBankMoney += (nextTx.getAmount() / 5)*3;
	}

	private void playerWin() {
		if (currentBankMoney > nextTx.getAmount() * 2) {
			sendAmount(nextTx.getAmount() * 2, nextPlayerToPay);
		} else {
			bankrupt();
		}

	}

	private void bankrupt() {
		sendAmount(currentBankMoney, nextPlayerToPay);
		sendAmount(jackpotMoney, nextPlayerToPay);
		currentBankOwner=null;
		currentBankMoney=0;
	}

	private long randomNumber() {
		hash = performSHA256_64(hash, hash);
		drawCard = hash & HASH_MASK;
		drawCard = drawCard % 13;
		drawCard += ONE;
		return drawCard;
	}

	private long drawCard() {
		long cardValue = randomNumber();
		return numberToCardValue(cardValue);
	}

	private long numberToCardValue(long n) {
		if (n == 1) return 11; // aces
		if (n > 10) return 10; // J, Q, K
		return n;
	}

	public void txReceived() {
		// Not needed, since the contract never leaves the loop on constructor.
	}

	public static void main(String[] args) throws Exception {
		BT.activateCIP20(true);
		new EmulatorWindow(CryptoBlackJack.class);
	}
}
